/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
sap.ui.define(["./three"],function(t){"use strict";var e=function(t,e){"use strict";function r(){throw new Error("BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.")}function n(t,r,n=true){if(!r||!r.isReady){throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.")}if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv")){throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.')}function o(t){if(t.normalized||t.isInterleavedBufferAttribute){const e=new Float32Array(t.getCount()*t.itemSize);for(let r=0,n=0;r<t.getCount();r++){e[n++]=t.getX(r);e[n++]=t.getY(r);if(t.itemSize>2){e[n++]=t.getZ(r)}}return e}if(t.array instanceof Float32Array){return t.array}return new Float32Array(t.array)}const s=t.index?t.toNonIndexed():t;const i=r.generateTangents(o(s.attributes.position),o(s.attributes.normal),o(s.attributes.uv));if(n){for(let t=3;t<i.length;t+=4){i[t]*=-1}}s.setAttribute("tangent",new e.BufferAttribute(i,4));if(t!==s){t.copy(s)}return t}function o(t,r=false){const n=t[0].index!==null;const o=new Set(Object.keys(t[0].attributes));const i=new Set(Object.keys(t[0].morphAttributes));const u={};const f={};const a=t[0].morphTargetsRelative;const c=new e.BufferGeometry;let l=0;for(let e=0;e<t.length;++e){const s=t[e];let m=0;if(n!==(s.index!==null)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");return null}for(const t in s.attributes){if(!o.has(t)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');return null}if(u[t]===undefined)u[t]=[];u[t].push(s.attributes[t]);m++}if(m!==o.size){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes.");return null}if(a!==s.morphTargetsRelative){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries.");return null}for(const t in s.morphAttributes){if(!i.has(t)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries.");return null}if(f[t]===undefined)f[t]=[];f[t].push(s.morphAttributes[t])}if(r){let t;if(n){t=s.index.count}else if(s.attributes.position!==undefined){t=s.attributes.position.count}else{console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute");return null}c.addGroup(l,t,e);l+=t}}if(n){let e=0;const r=[];for(let n=0;n<t.length;++n){const o=t[n].index;for(let t=0;t<o.count;++t){r.push(o.getX(t)+e)}e+=t[n].attributes.position.count}c.setIndex(r)}for(const t in u){const e=s(u[t]);if(!e){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute.");return null}c.setAttribute(t,e)}for(const t in f){const e=f[t][0].length;if(e===0)break;c.morphAttributes=c.morphAttributes||{};c.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let n=0;n<f[t].length;++n){e.push(f[t][n][r])}const n=s(e);if(!n){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" morphAttribute.");return null}c.morphAttributes[t].push(n)}}return c}function s(t){let r;let n;let o;let s=0;for(let e=0;e<t.length;++e){const i=t[e];if(i.isInterleavedBufferAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");return null}if(r===undefined)r=i.array.constructor;if(r!==i.array.constructor){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");return null}if(n===undefined)n=i.itemSize;if(n!==i.itemSize){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");return null}if(o===undefined)o=i.normalized;if(o!==i.normalized){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");return null}s+=i.array.length}const i=new r(s);let u=0;for(let e=0;e<t.length;++e){i.set(t[e].array,u);u+=t[e].array.length}return new e.BufferAttribute(i,n,o)}function i(t){if(t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute){return f(t)}if(t.isInstancedBufferAttribute){return(new e.InstancedBufferAttribute).copy(t)}return(new e.BufferAttribute).copy(t)}function u(t){let r;let n=0;let o=0;for(let e=0,s=t.length;e<s;++e){const s=t[e];if(r===undefined)r=s.array.constructor;if(r!==s.array.constructor){console.error("AttributeBuffers of different types cannot be interleaved");return null}n+=s.array.length;o+=s.itemSize}const s=new e.InterleavedBuffer(new r(n),o);let i=0;const u=[];const f=["getX","getY","getZ","getW"];const a=["setX","setY","setZ","setW"];for(let r=0,n=t.length;r<n;r++){const n=t[r];const o=n.itemSize;const c=n.count;const l=new e.InterleavedBufferAttribute(s,o,i,n.normalized);u.push(l);i+=o;for(let t=0;t<c;t++){for(let e=0;e<o;e++){l[a[e]](t,n[f[e]](t))}}}return u}function f(t){const r=t.data.array.constructor;const n=t.count;const o=t.itemSize;const s=t.normalized;const i=new r(n*o);let u;if(t.isInstancedInterleavedBufferAttribute){u=new e.InstancedBufferAttribute(i,o,s,t.meshPerAttribute)}else{u=new e.BufferAttribute(i,o,s)}for(let e=0;e<n;e++){u.setX(e,t.getX(e));if(o>=2){u.setY(e,t.getY(e))}if(o>=3){u.setZ(e,t.getZ(e))}if(o>=4){u.setW(e,t.getW(e))}}return u}function a(t){const e=t.attributes;const r=t.morphTargets;const n=new Map;for(const t in e){const r=e[t];if(r.isInterleavedBufferAttribute){if(!n.has(r)){n.set(r,f(r))}e[t]=n.get(r)}}for(const t in r){const e=r[t];if(e.isInterleavedBufferAttribute){if(!n.has(e)){n.set(e,f(e))}r[t]=n.get(e)}}}function c(t){let e=0;for(const r in t.attributes){const n=t.getAttribute(r);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const r=t.getIndex();e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0;return e}function l(t,r=1e-4){r=Math.max(r,Number.EPSILON);const n={};const o=t.getIndex();const s=t.getAttribute("position");const i=o?o.count:s.count;let u=0;const f=Object.keys(t.attributes);const a={};const c={};const l=[];const m=["getX","getY","getZ","getW"];const d=["setX","setY","setZ","setW"];for(let r=0,n=f.length;r<n;r++){const n=f[r];const o=t.attributes[n];a[n]=new e.BufferAttribute(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const s=t.morphAttributes[n];if(s){c[n]=new e.BufferAttribute(new s.array.constructor(s.count*s.itemSize),s.itemSize,s.normalized)}}const g=Math.log10(1/r);const b=Math.pow(10,g);for(let e=0;e<i;e++){const r=o?o.getX(e):e;let s="";for(let e=0,n=f.length;e<n;e++){const n=f[e];const o=t.getAttribute(n);const i=o.itemSize;for(let t=0;t<i;t++){s+=`${~~(o[m[t]](r)*b)},`}}if(s in n){l.push(n[s])}else{for(let e=0,n=f.length;e<n;e++){const n=f[e];const o=t.getAttribute(n);const s=t.morphAttributes[n];const i=o.itemSize;const l=a[n];const g=c[n];for(let t=0;t<i;t++){const e=m[t];const n=d[t];l[n](u,o[e](r));if(s){for(let t=0,o=s.length;t<o;t++){g[t][n](u,s[t][e](r))}}}}n[s]=u;l.push(u);u++}}const h=t.clone();for(const r in t.attributes){const t=a[r];h.setAttribute(r,new e.BufferAttribute(t.array.slice(0,u*t.itemSize),t.itemSize,t.normalized));if(!(r in c))continue;for(let t=0;t<c[r].length;t++){const n=c[r][t];h.morphAttributes[r][t]=new e.BufferAttribute(n.array.slice(0,u*n.itemSize),n.itemSize,n.normalized)}}h.setIndex(l);return h}function m(t,r){if(r===e.TrianglesDrawMode){console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");return t}if(r===e.TriangleFanDrawMode||r===e.TriangleStripDrawMode){let n=t.getIndex();if(n===null){const e=[];const r=t.getAttribute("position");if(r!==undefined){for(let t=0;t<r.count;t++){e.push(t)}t.setIndex(e);n=t.getIndex()}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");return t}}const o=n.count-2;const s=[];if(r===e.TriangleFanDrawMode){for(let t=1;t<=o;t++){s.push(n.getX(0));s.push(n.getX(t));s.push(n.getX(t+1))}}else{for(let t=0;t<o;t++){if(t%2===0){s.push(n.getX(t));s.push(n.getX(t+1));s.push(n.getX(t+2))}else{s.push(n.getX(t+2));s.push(n.getX(t+1));s.push(n.getX(t))}}}if(s.length/3!==o){console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.")}const i=t.clone();i.setIndex(s);i.clearGroups();return i}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r);return t}}function d(t){const r=new e.Vector3;const n=new e.Vector3;const o=new e.Vector3;const s=new e.Vector3;const i=new e.Vector3;const u=new e.Vector3;const f=new e.Vector3;const a=new e.Vector3;const c=new e.Vector3;function l(t,e,l,m,d,g,b,h){r.fromBufferAttribute(e,d);n.fromBufferAttribute(e,g);o.fromBufferAttribute(e,b);const p=t.morphTargetInfluences;if(l&&p){f.set(0,0,0);a.set(0,0,0);c.set(0,0,0);for(let t=0,e=l.length;t<e;t++){const e=p[t];const h=l[t];if(e===0)continue;s.fromBufferAttribute(h,d);i.fromBufferAttribute(h,g);u.fromBufferAttribute(h,b);if(m){f.addScaledVector(s,e);a.addScaledVector(i,e);c.addScaledVector(u,e)}else{f.addScaledVector(s.sub(r),e);a.addScaledVector(i.sub(n),e);c.addScaledVector(u.sub(o),e)}}r.add(f);n.add(a);o.add(c)}if(t.isSkinnedMesh){t.boneTransform(d,r);t.boneTransform(g,n);t.boneTransform(b,o)}h[d*3+0]=r.x;h[d*3+1]=r.y;h[d*3+2]=r.z;h[g*3+0]=n.x;h[g*3+1]=n.y;h[g*3+2]=n.z;h[b*3+0]=o.x;h[b*3+1]=o.y;h[b*3+2]=o.z}const m=t.geometry;const d=t.material;let g,b,h;const p=m.index;const A=m.attributes.position;const y=m.morphAttributes.position;const B=m.morphTargetsRelative;const w=m.attributes.normal;const T=m.morphAttributes.position;const E=m.groups;const x=m.drawRange;let z,I,S,G;let M;let V,v;const X=new Float32Array(A.count*A.itemSize);const R=new Float32Array(w.count*w.itemSize);if(p!==null){if(Array.isArray(d)){for(z=0,S=E.length;z<S;z++){M=E[z];V=Math.max(M.start,x.start);v=Math.min(M.start+M.count,x.start+x.count);for(I=V,G=v;I<G;I+=3){g=p.getX(I);b=p.getX(I+1);h=p.getX(I+2);l(t,A,y,B,g,b,h,X);l(t,w,T,B,g,b,h,R)}}}else{V=Math.max(0,x.start);v=Math.min(p.count,x.start+x.count);for(z=V,S=v;z<S;z+=3){g=p.getX(z);b=p.getX(z+1);h=p.getX(z+2);l(t,A,y,B,g,b,h,X);l(t,w,T,B,g,b,h,R)}}}else{if(Array.isArray(d)){for(z=0,S=E.length;z<S;z++){M=E[z];V=Math.max(M.start,x.start);v=Math.min(M.start+M.count,x.start+x.count);for(I=V,G=v;I<G;I+=3){g=I;b=I+1;h=I+2;l(t,A,y,B,g,b,h,X);l(t,w,T,B,g,b,h,R)}}}else{V=Math.max(0,x.start);v=Math.min(A.count,x.start+x.count);for(z=V,S=v;z<S;z+=3){g=z;b=z+1;h=z+2;l(t,A,y,B,g,b,h,X);l(t,w,T,B,g,b,h,R)}}}const U=new e.Float32BufferAttribute(X,3);const H=new e.Float32BufferAttribute(R,3);return{positionAttribute:A,normalAttribute:w,morphedPositionAttribute:U,morphedNormalAttribute:H}}function g(t){if(t.groups.length===0){console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.");return t}let e=t.groups;e=e.sort((t,e)=>{if(t.materialIndex!==e.materialIndex)return t.materialIndex-e.materialIndex;return t.start-e.start});if(t.getIndex()===null){const e=t.getAttribute("position");const r=[];for(let t=0;t<e.count;t+=3){r.push(t,t+1,t+2)}t.setIndex(r)}const r=t.getIndex();const n=[];for(let t=0;t<e.length;t++){const o=e[t];const s=o.start;const i=s+o.count;for(let t=s;t<i;t++){n.push(r.getX(t))}}t.dispose();t.setIndex(n);let o=0;for(let t=0;t<e.length;t++){const r=e[t];r.start=o;o+=r.count}let s=e[0];t.groups=[s];for(let r=1;r<e.length;r++){const n=e[r];if(s.materialIndex===n.materialIndex){s.count+=n.count}else{s=n;t.groups.push(s)}}return t}function b(t,r=Math.PI/3){const n=Math.cos(r);const o=(1+1e-10)*100;const s=[new e.Vector3,new e.Vector3,new e.Vector3];const i=new e.Vector3;const u=new e.Vector3;const f=new e.Vector3;const a=new e.Vector3;function c(t){const e=~~(t.x*o);const r=~~(t.y*o);const n=~~(t.z*o);return`${e},${r},${n}`}const l=t.toNonIndexed();const m=l.attributes.position;const d={};for(let t=0,r=m.count/3;t<r;t++){const r=3*t;const n=s[0].fromBufferAttribute(m,r+0);const o=s[1].fromBufferAttribute(m,r+1);const f=s[2].fromBufferAttribute(m,r+2);i.subVectors(f,o);u.subVectors(n,o);const a=(new e.Vector3).crossVectors(i,u).normalize();for(let t=0;t<3;t++){const e=s[t];const r=c(e);if(!(r in d)){d[r]=[]}d[r].push(a)}}const g=new Float32Array(m.count*3);const b=new e.BufferAttribute(g,3,false);for(let t=0,e=m.count/3;t<e;t++){const e=3*t;const r=s[0].fromBufferAttribute(m,e+0);const o=s[1].fromBufferAttribute(m,e+1);const l=s[2].fromBufferAttribute(m,e+2);i.subVectors(l,o);u.subVectors(r,o);f.crossVectors(i,u).normalize();for(let t=0;t<3;t++){const r=s[t];const o=c(r);const i=d[o];a.set(0,0,0);for(let t=0,e=i.length;t<e;t++){const e=i[t];if(f.dot(e)>n){a.add(e)}}a.normalize();b.setXYZ(e+t,a.x,a.y,a.z)}}l.setAttribute("normal",b);return l}t.computeMikkTSpaceTangents=n;t.computeMorphedAttributes=d;t.computeTangents=r;t.deepCloneAttribute=i;t.deinterleaveAttribute=f;t.deinterleaveGeometry=a;t.estimateBytesUsed=c;t.interleaveAttributes=u;t.mergeBufferAttributes=s;t.mergeBufferGeometries=o;t.mergeGroups=g;t.mergeVertices=l;t.toCreasedNormals=b;t.toTrianglesDrawMode=m;return t}({},t);return e});